<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Tim Ross]]></title>
  <link href="http://timrossinfo.github.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://timrossinfo.github.com/"/>
  <updated>2013-03-27T07:35:16+13:00</updated>
  <id>http://timrossinfo.github.com/</id>
  <author>
    <name><![CDATA[Tim Ross]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[More Fun With UIAppearance]]></title>
    <link href="http://timrossinfo.github.com/blog/2013/03/26/more-fun-with-uiappearance/"/>
    <updated>2013-03-26T20:14:00+13:00</updated>
    <id>http://timrossinfo.github.com/blog/2013/03/26/more-fun-with-uiappearance</id>
    <content type="html"><![CDATA[<p>In <a href="/uiappearance-with-uiss">my last post</a> I discussed using UIAppearance with <a href="http://github.com/robertwijas/UISS">UISS</a> to style iOS apps. Today I discovered a few more tricks with UIAppearance.</p>

<p>UIKit only exposes a limited set of elements that can be styled with UIAppearance. But what if we want to style something that's not exposed? Well, it turns out you can define your own UIAppearance proxies by appending a setter method declaration with <code>UI_APPEARANCE_SELECTOR</code>.</p>

<p>Say, for example, I want to use UIAppearance to set rounded corners on a UIView. I can create a <code>setCornerRadius</code> method on a UIView subclass that's appended with <code>UI_APPEARANCE_SELECTOR</code>:</p>

<p>``` objective-c
@interface MyView : UIView</p>

<ul>
<li>(void)setCornerRadius:(CGFloat)cornerRadius UI_APPEARANCE_SELECTOR;</li>
</ul>


<p>@end
```</p>

<p>UIView itself doesn't have a <code>corderRadius</code> property, so the implementation needs to set the value on the underlying CALayer:</p>

<p>``` objective-c
@implementation MyView</p>

<ul>
<li>(void)setCornerRadius:(CGFloat)cornerRadius {
  self.layer.cornerRadius = cornerRadius;
}</li>
</ul>


<p>@end
```</p>

<p>Now I can set the new <code>corderRadius</code> style on all instances of <code>MyView</code> with UIAppearance:</p>

<p><code>objective-c
[[MyView appearance] setCornerRadius:3];
</code></p>

<p>Or, with <a href="http://github.com/robertwijas/UISS">UISS</a> I can use JSON to set the style:</p>

<p>``` javascript
{</p>

<pre><code>"MyView": {
    "cornerRadius": 3
}
</code></pre>

<p>}
```</p>

<p>Now, this is pretty neat, but what if I want to expose <code>cornerRadius</code> on every UIView in the application, not just the subclass? Well, it turns out you can create a category on UIView that defines custom UIAppearance methods:</p>

<p>``` objective-c
@interface UIView (Appearance)</p>

<ul>
<li>(void)setCornerRadius:(CGFloat)cornerRadius UI_APPEARANCE_SELECTOR;</li>
<li>(void)setBorderColor:(UIColor *)borderColor UI_APPEARANCE_SELECTOR;</li>
<li>(void)setBorderWidth:(CGFloat)borderWidth UI_APPEARANCE_SELECTOR;</li>
</ul>


<p>@end</p>

<p>@implementation UIView (Appearance)</p>

<ul>
<li><p>(void)setCornerRadius:(CGFloat)cornerRadius {
  self.layer.cornerRadius = cornerRadius;
}</p></li>
<li><p>(void)setBorderColor:(UIColor *)borderColor {
  self.layer.borderColor = borderColor.CGColor;
}</p></li>
<li><p>(void)setBorderWidth:(CGFloat)borderWidth {
  self.layer.borderWidth = borderWidth;
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<p>So now every UIView in the application can have the <code>cornerRadius</code>, <code>borderColor</code> and <code>borderWidth</code> elements styled:</p>

<p>``` javascript
{</p>

<pre><code>"UIView": {
    "cornerRadius": 3,
    "borderColor": [26, 26, 26],
    "borderWidth": 1
}
</code></pre>

<p>}
```</p>

<p>Custom UIAppearance methods enable more elements to be exposed for styling. <a href="http://github.com/robertwijas/UISS">UISS</a> makes this code more readable by allowing styles to be defined using JSON.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Improving Readability of UIAppearance Code with UISS]]></title>
    <link href="http://timrossinfo.github.com/blog/2013/03/26/uiappearance-with-uiss/"/>
    <updated>2013-03-26T10:14:00+13:00</updated>
    <id>http://timrossinfo.github.com/blog/2013/03/26/uiappearance-with-uiss</id>
    <content type="html"><![CDATA[<p><a href="http://useyourloaf.com/blog/2012/08/24/using-appearance-proxy-to-style-apps.html">UIAppearance</a> is a convenient way to define styles for UIKit classes throughout your application. For example, instead of setting the font on every UILabel, you can define it once using a UIAppearance proxy:</p>

<p><code>objective-c
[[UILabel appearance] setFont:[UIFont fontWithName:@"Avenir-Medium" size:11]];
</code></p>

<p>Of course this is Objective-C, so the UIAppearance code is verbose and can be quite difficult to read. If you work with a designer who might like to tweak these values, the code can appear daunting. Luckily there's a quick and simple way to make UIAppearance code easier to read (and write!).</p>

<h2>Introducing UISS</h2>

<p><a href="http://github.com/robertwijas/UISS">UISS</a>, developed by <a href="http://robertwijas.com">Robert Wijas</a>, is an iOS library build on top of UIAppearance that provides a convenient way to define styles using JSON.</p>

<p>Let's look at a more complex example of styles defined in Objective-C using UIAppearance:</p>

<p><code>objective-c
[[UIButton appearance] setTitleColor:[UIColor colorWithRed:204.f/255.f green:204.f/255.f blue:204.f/255.f alpha:1] forState:UIControlStateNormal];
[[UIButton appearance] setTitleColor:[UIColor colorWithRed:160.f/255.f green:160.f/255.f blue:160.f/255.f alpha:1] forState:UIControlStateHighlighted];
[[UIButton appearance] setTitleShadowColor:[UIColor colorWithWhite:0 alpha:0.7] forState:UIControlStateNormal];
[[UIButton appearance] setBackgroundImage:[[UIImage imageNamed:@"ButtonGrey"] resizableImageWithCapInsets:UIEdgeInsetsMake(10, 10, 10, 10)] forState:UIControlStateNormal];
[[UIButton appearance] setBackgroundImage:[[UIImage imageNamed:@"ButtonGreyTap"] resizableImageWithCapInsets:UIEdgeInsetsMake(10, 10, 10, 10)] forState:UIControlStateHighlighted];
[[UILabel appearanceWhenContainedIn:[UIButton class], nil] setFont:[UIFont fontWithName:@"Avenir-Medium" size:11]];
[[UILabel appearanceWhenContainedIn:[UIButton class], nil] setShadowOffset:CGSizeMake(0, 1)];
</code></p>

<p>Now here's the equivalent styles defined in JSON using UISS:</p>

<p>``` javascript
{</p>

<pre><code>"UIButton": {
    "titleColor:normal": [204, 204, 204],
    "titleColor:highlighted": [160, 160, 160],
    "titleShadowColor:normal": ["black", 0.7],
    "backgroundImage:normal": ["ButtonGrey", 10, 10, 10, 10],
    "backgroundImage:highlighted": ["ButtonGreyTap", 10, 10, 10, 10],
    "UILabel": {
        "font": ["Avenir-Medium", 11],
        "shadowOffset": [0, 1]
    }
}
</code></pre>

<p>}
```</p>

<p>The UISS code is not only easier to read, but also more pleasurable to write!</p>

<p>UISS includes logging and a console for troubleshooting style problems. It can even generate the equivalent UIAppearance code from the JSON files, which is handy if you want to see exactly what's going on.</p>

<p>Styles can even be loaded from a remote server to enable live style updates in your app.</p>

<p>I was able to get up and running with UISS quickly and found it greatly improved the readability of my UIAppearance definitions. UISS is available on <a href="http://github.com/robertwijas/UISS">GitHub</a> or as a <a href="http://cocoapods.org/?q=uiss">Cocoapod</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[To Segue or Not to Segue]]></title>
    <link href="http://timrossinfo.github.com/blog/2013/03/19/to-segue-or-not-to-segue/"/>
    <updated>2013-03-19T10:38:00+13:00</updated>
    <id>http://timrossinfo.github.com/blog/2013/03/19/to-segue-or-not-to-segue</id>
    <content type="html"><![CDATA[<p>iOS 5 introduced <a href="http://www.raywenderlich.com/5138/beginning-storyboards-in-ios-5-part-1">Storyboards</a>, which allow you to visually define the flow of an app. The transitions between view controllers in a Storyboard are called "Segues".</p>

<p>Initially, the benefits of using segues seem clear:</p>

<ul>
<li>Spend less time writing boring transition code.</li>
<li>Code is cleaner and not littered with transitions.</li>
<li>You get a visual representation of how the app fits together.</li>
</ul>


<p>However, after using segues for a while I've found there are a few downsides:</p>

<ul>
<li>The visual layout is restricted. Segues always exit from right of a controller and enter from  the left. For any moderately complex app, you can end up with a storyboard that resembles spaghetti.</li>
<li>I almost always need to pass data to the controller I'm transitioning to. This requires dropping back to the code to intercept the segue, find the controller, then set its properties.</li>
<li>I often find I end up writing quite lengthy and obscure code to intercept the segue.</li>
</ul>


<p>Here's a comparison of transitioning using segues versus a traditional approach. In this code I'm handling tapping a detail accessory on a row in a table view, then transitioning to a view controller.</p>

<p>First, I'll use a segue:</p>

<p><img src="/images/segue1.png" width="789"></p>

<p>In theory I should just be able to connect a segue from the detail accessory to the next view controller and I'm done! Not quite... I also need to assign some data on the controller I'm transitioning to. So I need to intercept the segue by implementing the <code>prepareForSegue</code> method, then check the segue identifier to ensure I am handling the correct segue:</p>

<p>``` objective-c
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {</p>

<pre><code>if ([segue.identifier isEqualToString:@"ContactDetailSegue"]) {
    ContactDetailViewController *controller = segue.destinationViewController;
}
</code></pre>

<p>}
```</p>

<p>So I have the controller and now I need to assign some data to it. But how do I know which row was tapped? There is nothing in UITableView that stores the selected state for an accessory view. So I'll need an instance variable to store the row index and set this in the <code>tableView:accessoryButtonTappedForRowWithIndexPath:</code> method:</p>

<p>``` objective-c
- (void)tableView:(UITableView <em>)tableView accessoryButtonTappedForRowWithIndexPath:(NSIndexPath </em>)indexPath {</p>

<pre><code>self.selectedDetailIndexPath = indexPath;
</code></pre>

<p>}
```</p>

<p>Now I can use this to assign data to the controller I am transitioning to:</p>

<p>``` objective-c
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {</p>

<pre><code>if ([segue.identifier isEqualToString:@"ContactDetailSegue"]) {
    ContactDetailViewController *controller = segue.destinationViewController;
    Contact *contact = [self.contacts objectAtIndex:self.selectedDetailIndexPath.row];
    controller.contact = contact;
}
</code></pre>

<p>}
```</p>

<p>But hang on! The <code>tableView:accessoryButtonTappedForRowWithIndexPath:</code> method gets called <em>after</em> <code>prepareForSegue</code>, which means my <code>selectedDetailIndexPath</code> variable is not yet set. So now I need to disconnect the automatic segue from the detail accessory and instead create a <em>manual</em> segue between the two controllers.</p>

<p><img src="/images/segue2.png" width="789"></p>

<p>Next, I need to call <code>performSegueWithIdentifier</code> to manually trigger the segue in the <code>tableView:accessoryButtonTappedForRowWithIndexPath:</code> method</p>

<p>``` objective-c
- (void)tableView:(UITableView <em>)tableView accessoryButtonTappedForRowWithIndexPath:(NSIndexPath </em>)indexPath {</p>

<pre><code>self.selectedDetailIndexPath = indexPath;
[self performSegueWithIdentifier:@"ContactDetailSegue" sender:self];
</code></pre>

<p>}
```</p>

<p>Phew, that ended up being quite complicated.</p>

<p>Now, let's look at the "traditional" way of coding a transition without segues using <code>pushViewController</code>:</p>

<p>``` objective-c
- (void)tableView:(UITableView <em>)tableView accessoryButtonTappedForRowWithIndexPath:(NSIndexPath </em>)indexPath {</p>

<pre><code>ContactDetailViewController *controller = [self.storyboard instantiateViewControllerWithIdentifier:@"ContactDetailViewController"];
Contact *contact = [self.contacts objectAtIndex:indexPath.row];
controller.contact = contact;
[self.navigationController pushViewController:controller animated:YES];
</code></pre>

<p>}
```</p>

<p>That replaces all the previous code! Feels much simpler, doesn't it? What I like about this is that the transition code is all in one place, not spread across two methods. Sure, there's no "visual" representation of the transition, but if the code is clean and clear, it should be easy to determine how one controller transitions to the next.</p>

<p>So should you ditch using segues? Not necessarily. They can definitely save time if you are transitioning between static views. But there may be cases where it's cleaner and simpler to do a manual transition rather than use a segue.</p>

<p>Segues are a step in the right direction, the less code we have to write the better! Hopefully they'll continue to be improved in future updates of iOS. But with the current implementation, you often have to write quite obscure code to work-around the limitations.</p>
]]></content>
  </entry>
  
</feed>
